import random
import numpy as np
from midiutil import MIDIFile
import midi_scales
from midi_scales import *
import matplotlib.pyplot as plt


class BrownianMidiPart:
    '''
    Generates a random midi part, based on Brownian Motion.
    number_of_notes: the number of notes to generate
    key: 'C','C#','Db','D','D#','Eb','E','F','F#','Gb','G','G#','Ab','A','A#','Bb','B'
    mode: 'AEOLIAN', 'BLUES', 'CHROMATIC', 'DIATONIC_MINOR', 'DORIAN', 'HARMONIC_MINOR', 'INDIAN', 'LOCRIAN',
    'LYDIAN', 'MAJOR', 'MELODIC_MINOR', 'MINOR', 'MIXOLYDIAN', 'NATURAL_MINOR', 'PENTATONIC', 'PHRYGIAN', 'TURKISH' 
    lowest_note: the lowest note to generate, 0-127
    highest_note: the highest note to generate, 0-127
    tempo: the tempo in BPM
    number_of_parts: The number of midi parts to be generated
    '''
    plots = []
    
    def __init__(self, name='random_midi.mid',number_of_notes=200, key='C', mode='CHROMATIC', lowest_note=24, highest_note=108, min_velocity=60, max_velocity=110,tempo=120, spread=1):
        """
        
        :param name: name of file to be generated, usually 'abcxyz.mid'
        :param number_of_notes: I haven't written a way to track length and halt when desired length is achieved. Number
         of notes will have to do 
        :param key: 'C','C#','Db','D','D#','Eb','E','F','F#','Gb','G','G#','Ab','A','A#','Bb','B'
        :param mode: 'AEOLIAN', 'BLUES', 'CHROMATIC', 'DIATONIC_MINOR', 'DORIAN', 'HARMONIC_MINOR', 'INDIAN', 'LOCRIAN',
    'LYDIAN', 'MAJOR', 'MELODIC_MINOR', 'MINOR', 'MIXOLYDIAN', 'NATURAL_MINOR', 'PENTATONIC', 'PHRYGIAN', 'TURKISH'
        :param lowest_note: lowest note to generate, 0-127
        :param highest_note: highest note to generate, 0-127
        :param min_velocity: lowest velocity to generate, 0-127 
        :param max_velocity: highest velocity to generate, 0-127 
        :param tempo: tempo in BPM
        :param spread: sets the 'spread' of notes generated by note_list_gen()
        
        Also called by the init method:
        note_list_gen()
        get_scale_notes()
        map_to_scale()
        note_lengths = self.note_length(self.note_list_gen())
        note_spacing()
        note_velocity()
        """
        assert(lowest_note >= 0), 'No MIDI notes below 0!'
        assert(highest_note <= 127), 'No MIDI notes above 127!'
        self.name = name
        self.number_of_notes = number_of_notes
        self.key = key
        self.mode = mode
        self.lowest_note = lowest_note
        self.highest_note = highest_note
        self.min_velocity = min_velocity
        self.max_velocity = max_velocity
        self.tempo = tempo
        self.spread = spread
        self.note_list = self.note_list_gen()
        self.scale = self.get_scale_notes()
        self.mapped_notes = self.map_to_scale()
        self.note_lengths = self.note_length(self.note_list_gen())
        self.note_spacings = self.note_spacing()
        self.note_velocities = self.note_velocity()
        
    def note_list_gen(self, velocity=False):
        """
        Generate a list of random notes
        :param velocity: boolean, false for note generation, true for velocity generation
        :return: None
        """
        # rands: list, length=self.number_of_notes, uniform distribution with range= -spread to +spread
        rands = np.random.uniform(-1 * self.spread, 1 * self.spread, self.number_of_notes)
        brownian = np.cumsum(rands)# accumulate the random values in rands
        brownian -= np.min(brownian)# scale min value to 0
        brownian /= np.max(brownian)# scale max value to 1
        # spread values from min_value to max_value:
        if velocity:
            brownian = (self.max_velocity - self.min_velocity) * brownian + self.min_velocity 
        else:
            brownian = (self.highest_note - self.lowest_note) * brownian + self.lowest_note 
        brownian = np.round(brownian,decimals=0)
        note_list = brownian.astype(int)
        self.plots.append(note_list)
        return note_list
    
    def note_length(self, note_list):
        '''
        Turns a list of brownian values and turns it into note lengths or spacings
        :param note_list: a list of brownian values
        :return: a list of note lengths
        '''
        note_lengths = np.zeros(len(note_list))
        mn, mx = min(note_list), max(note_list)
        note_vals = np.linspace(mn, mx, 6)
        for i in range(len(note_list)):
            if note_list[i] < note_vals[1]:
                note_lengths[i] = 0.25
            elif note_vals[1] <= note_list[i] < note_vals[2]:
                note_lengths[i] = 0.5
            elif note_vals[2] <= note_list[i] < note_vals[3]:
                note_lengths[i] = 1.0
            elif note_vals[3] <= note_list[i] < note_vals[4]:
                note_lengths[i] = 2.0
            elif note_list[i] >= note_vals[4]:
                note_lengths[i] = 4.0
        BrownianMidiPart.plots.append(note_lengths)
        return note_lengths
    
    def note_spacing(self):
        note_list = self.note_list_gen() # generate a new note_list
        note_spacings = self.note_length(note_list)
        return note_spacings
    
    # def note_spacing2(self, n_beats):
    #     note_spacings = []
    #     # note_list = self.note_list_gen()
    #     # rng = (max(note_list) - min(note_list))
    #     pattern = self.note_pattern_gen(n_beats)
    #     while len(note_spacings) < len(self.note_list):
    #         note_spacings += pattern
    #     diff = len(note_spacings) - len(self.note_list)
    #     print(diff)
    #     if diff > 0:
    #         note_spacings = note_spacings[:-diff]
    #     self.note_spacings = note_spacings
    #     self.note_lengths = note_spacings
    #     print(note_spacings)
    #     print(len(note_spacings))
    #     # plt.plot(note_spacings)
    #     # plt.show()
    #     # self.note_spacings = self.note_length(note_list)
    #
    def note_velocity(self):
        note_list = self.note_list_gen(velocity=True)
        return note_list

    def note_pattern_gen(self, n_beats=4):
        # note_vals = [0.125, 0.1875, 0.25, 0.375, 0.5, 0.75, 1.0, 1.5, 2.0, 3.0, 4.0]
        note_vals = [0.125, 0.25, 0.5, 1.0, 2.0, 4.0]
        pattern = []
        count = 0
        while sum(pattern) <= n_beats * 2:
            count += 1
            if count > n_beats * 4:
                pattern = []
                count = 0
            if sum(pattern) == n_beats:
                break    
            new_note = np.random.choice(note_vals)
            pattern.append(new_note)
            if sum(pattern) > n_beats:
                while sum(pattern) > n_beats:
                    pattern.pop()
                    if sum(pattern) <= n_beats:
                        break
                    pattern.append(np.random.choice(note_vals))
        self.pattern = pattern
        return pattern
    
    def map_to_scale(self):
        '''
        maps a list of MIDI notes to the nearest MIDI note in a given scale
        scale: scale notes to map to
        returns: list of mapped notes
        '''
        tmp = []
        mapped_notes = []
        for note in self.note_list:# Iterate over note_list
            for target_note in self.scale:# iterate over scale notes
                tmp.append(abs(note - target_note))# create list of differences
            tmp = np.asarray(tmp)
            ind = np.where(tmp == min(tmp))[0][0]# get index of nearest note in scale
            mapped_notes.append(self.scale[ind])# append nearest note to mapped_notes
            tmp = []
        return mapped_notes

    def get_scale_notes(self):
        '''get scale note numbers for a given key and mode.'''
        shift = keys[self.key]
        scale = [note + shift for note in c_scales[self.mode] if self.lowest_note <= (note + shift) <= self.highest_note]
        return scale

    def get_scale_degrees(self):
        """get scale degrees for a given key and mode."""
        shift = keys[self.key]
        for mapped_note in self.mapped_notes:
            dict_key = (mapped_note - shift) % 12 # shift back to C and retrieve scale degrees
            note_name = midi_numbers[mapped_note] # retrieve note names
            print(note_name, scale_degrees[dict_key])

    def midi_gen(self, track_minutes = 2, tempo = 120, track=0, start_time=0, channel=0):
        MyMIDI = MIDIFile(1, adjust_origin=False)  # One track, defaults to format 1 (tempo track is created automatically)
        MyMIDI.addTempo(track, start_time, self.tempo)
        # duration_list = []
        elapsed_time = 0
        data = zip(self.note_lengths, self.note_spacings, self.mapped_notes, self.note_velocities)
        for i, tup in enumerate(data):
            note_length, note_spacing, mapped_note, note_velocity = tup
            elapsed_time += note_spacing
            MyMIDI.addNote(track, channel, mapped_note, start_time + elapsed_time, note_spacing, note_velocity)
            MyMIDI.addTrackName(0,0,self.name)
            # duration_list += [note_spacing]
            if elapsed_time > track_minutes * tempo:
                break
        with open(self.name, "wb") as output_file:
            MyMIDI.writeFile(output_file)
    
def plot():
    for plot in BrownianMidiPart.plots:
        plt.plot(list(plot))
        # plt.plot()
    plt.show()
    
if __name__ == '__main__':
    
    test = BrownianMidiPart(key='F#', mode='MINOR', tempo=180)
    test.get_scale_degrees()
    
